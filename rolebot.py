"""
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.

Copyright (C) 2022 Michael Hall <https://github.com/mikeshardmind>
"""

from __future__ import annotations

import argparse
import getpass
import logging
import os
import re
import struct
from collections.abc import Generator, Iterator
from itertools import chain
from pathlib import Path
from typing import NamedTuple, Self

import base2048
import discord
import msgspec
import platformdirs
import xxhash
from cryptography.exceptions import InvalidTag
from cryptography.hazmat.primitives.ciphers.aead import AESSIV  # See security considerations below if concerned

try:
    import uvloop  # type: ignore
except ModuleNotFoundError:
    uvloop = None

log = logging.getLogger(__name__)
platformdir_stuff = platformdirs.PlatformDirs("discord-rolebot", "mikeshardmind", roaming=False)

##################################### SECURITY CONSIDERATIONS  #####################################
#
# The key is kept secret
# Associated data is known by all parties, that being [message_id, button_index],
# message id is generated by discord, snowflake, 8 bytes. button index is a value from 0-24, 1 byte
# {plaintext, associated_data} is a never-reused combination.
# Encryption is only ever performed once for any one of associated data,
# multiple plaintexts must not re-use associated data
#
# Not in scope: Compromise of key via access to the key outside of what this service enables.
#
# Primary concern & scope: Spoofed custom_id in interaction payload from discord.
#
# The original concerns here involved that in the past it was possible for users to spoof
# interaction data and discord would not validate it before sending it to bots.
# According to a conversation in the discord.py discord server, this should no longer be possible.
# Given the potential negative impact, as well as discord's track record, it's unacceptable to
# trust that this will remain in a "safe" state.
# Recent issue:  XSS in December 2022
# Previous issues: this, various misunderstandings of sanitization and validation issues, etc
#
# Addtiional consideration: Known plaintext with AEESIV
#
# As the code here is open source, and the users effectively may know the plaintext
# Within restriction based on discord snowflake format,
# and limitations of the constrained scheme below, users may choose the plain text.
# The effort involved in a Known plaintext attack must be considered.
# In the case of such an attack, a user could attempt to attack the key.
# As we do not differentiate to an attacker any of the potential reasons this could fail,
# The attack would be limited by all of the below factors
#
# 1. Discord interaction ratelimits.
#       (TODO: add throttling on the bot end to ensure this isn't another discord failure point.)
# 2. The ability to spoof interaction data
#       (The window to attack would be limited to a time when this is possible) (See above)
# 3. Not entirely up to the user: plaintext
# 4. Not chosen by the user: associated data.
# 5. Attempts at this would raise suspicion based on logging
#       (weak until TODO: alarming on specific exceptions not yet implemented)
# 6. Existing resistance against such attacks in AES-SIV
#   - `Deterministic Authenticated-Encryption: A Provable-Security Treatment of the Key-Wrap Problem`
#   - Sections 6-8
#   - Link: https://eprint.iacr.org/2006/221
# 7. Arguments of economics as well as thermodynamic ideals
#   - See https://www.schneier.com/blog/archives/2009/09/the_doghouse_cr.html
#
# If you find a security issue in this, please reach out.
#
# POTENTIAL IMPACT:
# Successful spoofing of this data could lead to a malicious user granting
# themselves more permissions and roles in discord. Such escalation can
# Can indirectly lead to more than the permissions the roles themselves have
# in certain cases involving bots which use roles to indicate priveleged user groups
# rather than use the permissions of the roles directly
#
# No direct security impact to host, potential security impact to users of the provided service.
#
####################################################################################################


########################################## Struct layouts ##########################################
# Space available: 100 utf-8 characters. 5 charcters used for plaintext prefix matching.
# Assumptions: base2048, 95 utf-8 characters, full bytes only, aessiv with a 256 bit key
# Note: 256 bit key corresponds to AESSIV.generate_key(512)
# Effective space is 95 characters of base2048 in byte increments, or 130 bytes
# AES-SIV has a 16 byte overhead to it in these conditions, leaving 114 bytes
# We can reasonably version within a single byte
# Each discord id is 8 bytes, and we have 6 discrete sets of ids
# We also need to reserve space for a version to allow future changes as needed.
# --------------------------------------------------------------------------------------------------
# Common:
# up to 112 byte payload
# 1-byte: version | up to 111 bytes: versioned data
# --------------------------------------------------------------------------------------------------
# Version 1:
# 1-byte: version = x01 | 6 length prefixed arrays of discord ids to be used in application as a set
#                           legnth prefix as 1 byte, elements 8 bytes each representing a 64bit int
# each of these sets are used in a ruleset to represent a combination of actions and conditions:
# (in order) to add, to remove, to toggle, to require any of, to require all of, to forbid any of
####################################################################################################


class NoUserFeedback(Exception):
    """Used to mark exceptions that should consistently just mark something a failure"""


class RuleError(Exception):
    """Used to indicate issues with specific rules"""


class V1TooManyIDs(RuleError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("May only pack 13 discord ids into a version 1 ruleset")


class V1ToggleWithAddRemove(RuleError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("Can't mix toggle with add or remove")


class V1AddRemoveOverlap(RuleError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("Can't have a role be both added and removed")


class V1MultipleToggle(RuleError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("May only toggle 1 role at once")


class V1NonActionableRule(RuleError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("Must provide at least one action from add, remove, or toggle")


class RulesFileError(Exception):
    """Used to indicate errors involving user-provided rules files"""


class NoContent(RulesFileError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("Must provide content for the message the menu will be attached to")


class EmptyLabel(RulesFileError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("Label must contain some text")


class NonStringLabel(RulesFileError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("Label must be a string")


class NonStringContent(RulesFileError):
    def __init__(self: Self, *args: object) -> None:
        super().__init__("`Content` key must contain a string")


class BadIDList(RulesFileError):
    def __init__(self: Self, bad_key: str, *args: object) -> None:
        self.bad_key = bad_key
        super().__init__(f"Key: {bad_key} should be a list of integer role ids")


class UserFacingError(Exception):
    def __init__(self: Self, error_message: str, *args: object) -> None:
        self.error_message = error_message
        super().__init__(*args)


class NoSuchRole(UserFacingError):
    def __init__(self: Self, role_id: int, *args: object) -> None:
        super().__init__(f"I can't find a role with id {role_id}")


class UserHierarchyIssue(UserFacingError):
    def __init__(self: Self, role: discord.Role, *args: object) -> None:
        super().__init__(f"You can't create a rule for {role.mention} as it could violate discord role hierarchy")


class BotHierarchyIssue(UserFacingError):
    def __init__(self: Self, role: discord.Role, *args: object) -> None:
        super().__init__(f"I can't assign {role.mention} as it is not below my top role.")


class CantAssignManagedRole(UserFacingError):
    def __init__(self: Self, role: discord.Role, *args: object) -> None:
        super().__init__(f"{role.mention} is managed by an integration and cannot be assigned like this.")


class TomlDataV1Button(msgspec.Struct):
    label: str
    add: frozenset[int] = frozenset()
    remove: frozenset[int] = frozenset()
    toggle: frozenset[int] = frozenset()
    require_any: frozenset[int] = frozenset()
    require_all: frozenset[int] = frozenset()
    require_none: frozenset[int] = frozenset()

    def __iter__(self: Self) -> Generator[frozenset[int], None, None]:
        yield from (self.add, self.remove, self.toggle, self.require_any, self.require_all, self.require_none)


class TomlConfiguration(msgspec.Struct):
    content: str
    buttons: list[TomlDataV1Button]


class DataV1(NamedTuple):
    add: frozenset[int]
    remove: frozenset[int]
    toggle: frozenset[int]
    require_any: frozenset[int]
    require_all: frozenset[int]
    require_none: frozenset[int]


def validate_datav1(data: DataV1 | TomlDataV1Button) -> None:
    """
    Checks that
    - there are 13 or fewer discord ids encoded
    - that toggle is not provided with either add or remove
    - that toggle contains no more than 1 role
    - that at least one of toggle, add, or remove is provided
    - that roles provided in add are not also provided in removed.
    """

    if (
        sum(
            map(len, (data.add, data.remove, data.toggle, data.require_any, data.require_all, data.require_none)),
        )
        > 13
    ):
        raise V1TooManyIDs

    if tog := data.toggle:
        if data.add or data.remove:
            raise V1ToggleWithAddRemove
        if len(tog) > 1:
            raise V1MultipleToggle
    else:
        if not (data.add or data.remove):
            raise V1NonActionableRule
        if data.add & data.remove:
            raise V1AddRemoveOverlap


def apply_datav1_to_ids(data: DataV1 | TomlDataV1Button, ids: set[int], /) -> set[int]:
    return ((ids ^ data.toggle) | data.add) - data.remove


def check_datav1_rules_against_ids(data: DataV1 | TomlDataV1Button, ids: set[int], /) -> bool:
    """
    Checks if a hypothetical set of ids meet requirements
    """

    if data.require_any and not (data.require_any & ids):
        return False

    if (data.require_all & ids) - data.require_all:
        return False

    if data.require_none & ids:
        return False

    return True


# can expand this to a type union if needed later on,
# until then it's an alias where future API should handle this
VERSIONED_DATA = DataV1
VERSIONED_DATA_TOML = TomlDataV1Button


def pack_rules(data: VERSIONED_DATA | TomlDataV1Button, /) -> bytes:
    validate_datav1(data)
    struct_fmt = "!bb%dQb%dQb%dQb%dQb%dQb%dQ" % tuple(map(len, data))
    to_pack = chain.from_iterable((len(lst), *lst) for lst in data)
    return struct.pack(struct_fmt, 1, *to_pack)  # needs changing if new version


def _v1_struct_unpacker(raw: bytes, /) -> Iterator[frozenset[int]]:
    """
    Calling contract is that you have checked the version in advance
    """
    offset: int = 1
    for _ in range(6):
        (_len,) = struct.unpack_from("!b", raw, offset)
        yield frozenset(struct.unpack_from("!%dQ" % _len, raw, offset + 1))
        offset += 8 * _len + 1


def _get_data_version(b: bytes, /) -> int:
    (r,) = struct.unpack_from("!b", b, 0)
    assert isinstance(r, int)
    return r


def unpack_rules(raw: bytes, /) -> VERSIONED_DATA:
    """
    Errors here should not be reported to users.
    These should be pass/fail only to them.

    Potential place to consider impact of a timing attack,
    but I doubt what's here is meaningfully susceptible to that
    when it should be eclipsed by the networking delays from
    bot <-> discord <-> user
    as well as by various ratelimits
    (already inconsistent response time for a basic always respond interaction)
    """
    try:
        version = _get_data_version(raw)
    except struct.error:
        raise NoUserFeedback from None

    if version != 1:
        raise NoUserFeedback

    try:
        data = DataV1(*_v1_struct_unpacker(raw))
        validate_datav1(data)
    except (NoUserFeedback, struct.error):
        raise NoUserFeedback from None
    except Exception as exc:
        log.exception("Unhandled exception type", exc_info=exc)
        raise NoUserFeedback from None

    return data


def resolve_path_with_links(path: Path, folder: bool=False) -> Path:
    """
    Python only resolves with strict=True if the path exists.
    """
    try:
        return path.resolve(strict=True)
    except FileNotFoundError:
        path = resolve_path_with_links(path.parent, folder=True) / path.name
        if folder:
            path.mkdir(mode=0o700)  # python's default is world read/write/traversable... (0o777)
        else:
            path.touch(mode=0o600)  # python's default is world read/writable... (0o666)
        return path.resolve(strict=True)


def get_secret_data_from_file(path: Path) -> tuple[int, AESSIV]:
    """
    We get back a number that represents an equivalent
    time portion of a discord snowflake (snowflake >> 22)
    for when a key was generated ad well as a key
    """
    path = resolve_path_with_links(path)
    with path.open(mode="rb") as fp:
        raw = fp.read()
        ts, k = struct.unpack("!Q64s", raw)
        return ts, AESSIV(k)


def _generate_secret_data_file(path: Path) -> None:
    """
    Writes a file in the format expected by `get_secret_data`
    after generating the values and writes to a path.

    assumes system clock is fine.

    will not overwrite existing data.
    (barring race conditions not considered in scope to account for at this time)
    """

    key = AESSIV.generate_key(512)
    time = discord.utils.time_snowflake(discord.utils.utcnow()) >> 22
    path = resolve_path_with_links(path, folder=True)

    with path.open(mode="a+b") as fp:
        # a opens seeked to end of file, we use this here
        # to ensure we aren't overwriting. it's worse than opening with x, but opening with x
        # prevents us from controlling the file access prior to writing anything,
        # and python's default is world read/writable
        if fp.tell() != 0:
            return
        fp.write(struct.pack("!Q64s", time, key))


def parse_and_check_rules(
    guild: discord.Guild,
    user: discord.Member,
    raw: bytes,
) -> TomlConfiguration:
    generic_msg = "Something was wrong with that file (More detailed errors may be provided in the future.)"
    try:
        config = msgspec.toml.decode(raw, type=TomlConfiguration)
    except msgspec.ValidationError:
        raise UserFacingError(generic_msg) from None

    if not config.buttons:
        msg = "Must provide between 1 and 25 buttons"
        raise UserFacingError(msg)

    for button in config.buttons:
        if not button.label:
            raise EmptyLabel

        validate_datav1(button)

        for rid in chain(button.add, button.remove, button.toggle):
            role = guild.get_role(rid)
            if role is None:
                raise NoSuchRole(rid)
            if role >= user.top_role and user.id != guild.owner_id:
                raise UserHierarchyIssue(role)
            if role >= guild.me.top_role and guild.me.id != guild.owner_id:
                raise BotHierarchyIssue(role)

    return config


role_menu_group = discord.app_commands.Group(
    name="createrolemenu",
    guild_only=True,
    default_permissions=discord.Permissions(268435456),
)


@role_menu_group.command(name="fromfile")
async def role_menu_maker(itx: discord.Interaction[RoleBot], attachment: discord.Attachment) -> None:
    """
    This function creates a role menu from an attachment.

    To be better documented soon :tm:
    May also create a web interface, who knows.
    """
    # guild only decorator, not checking for discord/discord.py failures here
    assert isinstance(itx.user, discord.Member)
    assert itx.guild

    if not isinstance(itx.channel, discord.TextChannel):
        # I don't think this is gonna come up??
        await itx.response.send_message("Use this in a text channel instead", ephemeral=True)
        return

    # Even if someone modifies the app command settings, we aren't gonna allow this. It's privesc
    if not itx.user.guild_permissions.manage_roles:
        await itx.response.send_message("You can't do this. (missing permissions)", ephemeral=True)
        return

    await itx.response.defer(ephemeral=True)

    try:
        config = parse_and_check_rules(itx.guild, itx.user, await attachment.read())

    except UserFacingError as exc:
        await itx.followup.send(exc.error_message, ephemeral=True)
        return

    try:
        await itx.client.create_role_menu(itx.channel, config=config)
    except (RuleError, RulesFileError, discord.HTTPException):
        await itx.followup.send("Something went wrong. (more detailed error in future versions)")
        return

    # It'll get stuck thinking without this, thanks discord...
    await itx.followup.send("Menu created", ephemeral=True)


class VersionableTree(discord.app_commands.CommandTree):
    async def get_hash(self: Self) -> bytes:
        commands = sorted(self._get_all_commands(guild=None), key=lambda c: c.qualified_name)

        translator = self.translator
        if translator:
            payload = [await command.get_translated_payload(translator) for command in commands]
        else:
            payload = [command.to_dict() for command in commands]

        return xxhash.xxh64_digest(msgspec.msgpack.encode(payload), seed=0)


class RoleBot(discord.AutoShardedClient):
    def __init__(self: Self, valid_since: int, aessiv: AESSIV) -> None:
        super().__init__(intents=discord.Intents(1))
        self.aessiv = aessiv
        self.valid_since = valid_since
        self.interaction_regex = re.compile(r"^rr(\d{2}):(.*)$", flags=re.DOTALL)
        self.tree = VersionableTree(self, fallback_to_global=False)

    async def setup_hook(self: Self) -> None:
        self.tree.add_command(role_menu_group)
        tree_hash = await self.tree.get_hash()
        path = platformdir_stuff.user_cache_path / "tree.hash"
        path = resolve_path_with_links(path)
        with path.open(mode="r+b") as fp:
            data = fp.read()
            if data != tree_hash:
                await self.tree.sync()
                fp.seek(0)
                fp.write(tree_hash)

    async def on_interaction(self: Self, interaction: discord.Interaction[Self]) -> None:
        if interaction.type is discord.InteractionType.component:
            # components *should* be guaranteed to have a custom_id by discord
            assert interaction.data is not None
            custom_id = interaction.data.get("custom_id", "")
            # above avoids relying on non-publicly exported types in an assertion
            if m := self.interaction_regex.match(custom_id):
                guild = interaction.guild
                if guild is None or not guild.me.guild_permissions.manage_roles:
                    await interaction.response.defer()
                    return
                index, rules = m.groups()
                await self.handle_rules_for_interaction(interaction, int(index), rules)

    def _decrypt_and_parse_rules(
        self: Self,
        msg_id: int,
        user_id: int,
        index: int,
        encoded_rules: str,
    ) -> VERSIONED_DATA:
        """
        Handles decryption and parsing of rules, logging / raising if needed.
        """
        if (msg_id >> 22) < self.valid_since:
            log.info(
                "Not processing button that predates key on message_id: %d from user: %d",
                msg_id,
                user_id,
            )
            raise NoUserFeedback

        try:
            by = base2048.decode(encoded_rules)
        except Exception:
            log.exception(
                "SEC: Could not decode expected valid custom id using base2048: %s from user %d",
                encoded_rules,
                user_id,
            )
            raise NoUserFeedback from None

        associated_data = [msg_id.to_bytes(8, byteorder="big"), index.to_bytes(1, byteorder="big")]

        try:
            packed_rules = self.aessiv.decrypt(by, associated_data)
        except InvalidTag:
            log.exception(
                "SEC: Got a custom id %s that couldn't decrypt with aessiv key from user %d",
                encoded_rules,
                user_id,
            )
            raise NoUserFeedback from None

        try:
            rules = unpack_rules(packed_rules)
        except NoUserFeedback:
            log.exception(
                "SEC: Could not unpack custom_id %s after decryption passed from user %d",
                encoded_rules,
                user_id,
            )
            raise

        return rules

    @staticmethod
    def _preempt_role_violations(
        interaction: discord.Interaction,
        rules_pack: str,
        added: set[int],
        removed: set[int],
    ) -> None:
        guild = interaction.guild
        message = interaction.message

        assert guild
        assert message

        for rid in chain(added, removed):
            if role := guild.get_role(rid):
                if role.managed:
                    # this should only happen if a role can *become* managed. not putting it past discord to change this
                    CantAssignManagedRole(role)
                if role >= guild.me.top_role:
                    raise BotHierarchyIssue(role)
            else:
                # SEC: There's a balance between security and usability to consider below
                # The ideal for security is to silently fail here too.
                # The reality is that successfully attacking to this point
                # and not tripping prior alarms for an extended period measuring years...
                # If the id is impossible, it must be part of an attempt at attacking this or a major flaw
                # in the way something is handled to get to this state.
                # Otherwise, given the various factors at play, we'll assume the benign case of a role being deleted
                # after a menu was created referencing it.

                if (rid.bit_length() < 43) or (  # impossible snowflake
                    (guild.id >> 22) < (rid >> 22) < (message.id >> 22)
                ):  # temporally anomalous
                    log.critical(
                        "SEC: passed decryption, passed unpack, impossible ID %d from packed rules %s from user %d",
                        rid,
                        rules_pack,
                        interaction.user.id,
                    )
                    raise NoUserFeedback
                raise NoSuchRole(rid)

    async def handle_rules_for_interaction(
        self: Self,
        interaction: discord.Interaction[Self],
        index: int,
        encoded_rules: str,
    ) -> None:
        await interaction.response.defer(ephemeral=True)

        # calling contract here ensures:
        # 1. That the message exists
        # 2. That the guild exists
        # 3. that the user is a member
        assert interaction.message is not None
        assert isinstance(interaction.user, discord.Member)
        message = interaction.message
        user = interaction.user

        rules = self._decrypt_and_parse_rules(message.id, user.id, index, encoded_rules)

        starting_role_ids = {r.id for r in user.roles}

        if not check_datav1_rules_against_ids(rules, starting_role_ids):
            await interaction.followup.send(
                content="You are ineligible to use this button",
                ephemeral=True,
            )
            return

        new_role_ids = apply_datav1_to_ids(rules, starting_role_ids)
        # not using symetric difference here because we need these seperately later anyhow
        added = new_role_ids - starting_role_ids
        removed = starting_role_ids - new_role_ids

        if not (added or removed):
            return

        try:
            self._preempt_role_violations(interaction, encoded_rules, added, removed)
        except UserFacingError as exc:
            await interaction.followup.send(content=exc.error_message, ephemeral=True)
            return
        except NoUserFeedback:
            return

        try:
            await user.edit(
                roles=[discord.Object(rid) for rid in new_role_ids],
                reason="Used a role button.",
            )
        except discord.HTTPException as exc:
            log.exception(
                "Error assigning role from button when expected to work code: %d  status: %d",
                exc.code,
                exc.status,
                exc_info=exc,
            )
        else:
            add_str = rem_str = ""
            if added:
                add_str = "Added roles: " + ", ".join(f"<@&{rid}>" for rid in added)
            if removed:
                rem_str = "Removed roles: " + ", ".join(f"<@&{rid}>" for rid in removed)

            content = "\n".join(filter(None, (add_str, rem_str)))
            await interaction.followup.send(content=content, ephemeral=True)

    async def create_role_menu(
        self: Self,
        channel: discord.TextChannel,
        config: TomlConfiguration,
    ) -> discord.Message:
        view = discord.ui.View(timeout=None)
        view.stop()

        message = await channel.send(content=config.content)

        for idx, data in enumerate(config.buttons):
            packed = pack_rules(data)
            associated_data = [message.id.to_bytes(8, byteorder="big"), idx.to_bytes(1, byteorder="big")]
            enc = self.aessiv.encrypt(packed, associated_data)
            to_disc = base2048.encode(enc)
            custom_id = f"rr{idx:02}:{to_disc}"
            button: discord.ui.Button[discord.ui.View] = discord.ui.Button(label=data.label, custom_id=custom_id)
            view.add_item(button)

        try:
            await message.edit(view=view)
        except Exception as exc:
            log.exception("edit fail", exc_info=exc)
            try:
                await message.delete()
            except discord.HTTPException:
                pass

        return message


def _get_stored_token() -> str | None:
    token_file_path = platformdir_stuff.user_config_path / "rolebot.token"
    token_file_path = resolve_path_with_links(token_file_path)
    with token_file_path.open(mode="r") as fp:
        data = fp.read()
        return base2048.decode(data).decode("utf-8") if data else None

def _store_token(token: str, /) -> None:
    token_file_path = platformdir_stuff.user_config_path / "rolebot.token"
    token_file_path = resolve_path_with_links(token_file_path)
    with token_file_path.open(mode="w") as fp:
        fp.write(base2048.encode(token.encode()))

def _get_token() -> str:
    # TODO: alternative token stores: systemdcreds, etc
    token = os.getenv("ROLEBOT_TOKEN") or _get_stored_token()
    if not token:
        msg = "NO TOKEN? (Use Environment `ROLEBOT_TOKEN` or launch with `--setup` to go through interactive setup)"
        raise RuntimeError(msg) from None
    return token


def run_generate_secret() -> None:
    secrets_file_path = platformdir_stuff.user_config_path / "rolebot.secrets"
    _generate_secret_data_file(secrets_file_path)


def run_setup() -> None:
    prompt = (
        "Paste the discord token you'd like to use for this bot here (won't be visible) then press enter. "
        "This will be stored for later use >"
    )
    token = getpass.getpass(prompt)
    if not token:
        msg = "Not storing empty token"
        raise RuntimeError(msg)
    _store_token(token)


def run_bot() -> None:
    if uvloop is not None:
        uvloop.install()  # type: ignore
    token = _get_token()
    secrets_file_path = platformdir_stuff.user_config_path / "rolebot.secrets"

    try:
        valid_since, aessiv = get_secret_data_from_file(secrets_file_path)
    except Exception:  # noqa: BLE001
        msg = (
            f"Generated secrets file not found in expected path {secrets_file_path}, "
            "run with --gen-secret to generate this automatically"
        )
        raise RuntimeError(msg) from None

    client = RoleBot(valid_since, aessiv)
    client.run(token)


if __name__ == "__main__":
    os.umask(0o077)
    parser = argparse.ArgumentParser(description="A minimal configuration discord bot for role menus")
    excl_setup = parser.add_mutually_exclusive_group()
    excl_setup.add_argument("--setup", action="store_true", default=False, help="Run interactive setup.", dest="isetup")
    excl_setup.add_argument(
        "--set-token-to",
        default=None,
        dest="token",
        help="Provide a token directly to be stored in the system keyring.",
    )
    parser.add_argument(
        "--gen-secret",
        action="store_true",
        default=False,
        help="Generate and store secret key (without overwriting existing)",
        dest="gen_secret",
    )
    args = parser.parse_args()

    if args.gen_secret:
        run_generate_secret()
    elif args.isetup:
        run_setup()
    elif args.token:
        _store_token(args.token)
    else:
        run_bot()
